<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebCraft - Minecraft Clone</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            overflow: hidden;
            font-family: 'Courier New', monospace;
            touch-action: none;
            user-select: none;
        }
        
        #gameCanvas {
            width: 100vw;
            height: 100vh;
            display: block;
        }
        
        #crosshair {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            pointer-events: none;
            z-index: 100;
        }
        
        #crosshair::before,
        #crosshair::after {
            content: '';
            position: absolute;
            background: white;
            box-shadow: 0 0 3px rgba(0,0,0,0.5);
        }
        
        #crosshair::before {
            width: 2px;
            height: 20px;
            left: 9px;
        }
        
        #crosshair::after {
            width: 20px;
            height: 2px;
            top: 9px;
        }
        
        #ui {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
            z-index: 10;
        }
        
        #hotbar {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 2px;
            background: rgba(0,0,0,0.5);
            padding: 5px;
            border: 2px solid #333;
        }
        
        .hotbar-slot {
            width: 50px;
            height: 50px;
            border: 2px solid #666;
            background: rgba(139,69,19,0.3);
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 10px;
            text-align: center;
            position: relative;
        }
        
        .hotbar-slot.active {
            border-color: #fff;
            box-shadow: 0 0 10px rgba(255,255,255,0.5);
        }
        
        .hotbar-slot .count {
            position: absolute;
            bottom: 2px;
            right: 2px;
            font-size: 12px;
            color: yellow;
            text-shadow: 1px 1px 2px black;
        }
        
        #stats {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        }
        
        .bar {
            width: 200px;
            height: 20px;
            border: 2px solid #333;
            background: rgba(0,0,0,0.5);
            margin: 5px 0;
            position: relative;
        }
        
        .bar-fill {
            height: 100%;
            transition: width 0.3s;
        }
        
        .health-fill {
            background: linear-gradient(90deg, #ff3333, #ff6666);
        }
        
        .hunger-fill {
            background: linear-gradient(90deg, #8B4513, #D2691E);
        }
        
        .bar-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 12px;
            font-weight: bold;
        }
        
        #inventory {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(139,69,19,0.95);
            border: 3px solid #333;
            padding: 20px;
            display: none;
            pointer-events: all;
            z-index: 1000;
        }
        
        #inventory.open {
            display: block;
        }
        
        .inventory-grid {
            display: grid;
            grid-template-columns: repeat(9, 50px);
            gap: 2px;
            margin-top: 10px;
        }
        
        .inventory-slot {
            width: 50px;
            height: 50px;
            border: 2px solid #666;
            background: rgba(0,0,0,0.3);
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 10px;
            cursor: pointer;
            position: relative;
        }
        
        .inventory-slot:hover {
            border-color: #fff;
        }
        
        #mobileControls {
            display: none;
            position: fixed;
            bottom: 100px;
            left: 20px;
            z-index: 100;
            pointer-events: all;
        }
        
        .joystick {
            width: 120px;
            height: 120px;
            background: rgba(255,255,255,0.2);
            border-radius: 50%;
            position: relative;
            border: 2px solid rgba(255,255,255,0.4);
        }
        
        .joystick-knob {
            width: 40px;
            height: 40px;
            background: rgba(255,255,255,0.6);
            border-radius: 50%;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }
        
        .mobile-buttons {
            position: fixed;
            bottom: 100px;
            right: 20px;
            display: none;
            gap: 10px;
            z-index: 100;
            pointer-events: all;
        }
        
        .mobile-btn {
            width: 60px;
            height: 60px;
            background: rgba(255,255,255,0.3);
            border: 2px solid rgba(255,255,255,0.5);
            border-radius: 10px;
            color: white;
            font-size: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        @media (max-width: 768px) {
            #mobileControls, .mobile-buttons {
                display: flex;
            }
            
            .hotbar-slot {
                width: 40px;
                height: 40px;
            }
        }
        
        #blockBreaking {
            position: fixed;
            pointer-events: none;
            z-index: 5;
        }
    </style>
</head>
<body>
    <div id="crosshair"></div>
    
    <div id="ui">
        <div id="stats">
            <div class="bar">
                <div class="bar-fill health-fill" id="healthBar" style="width: 100%"></div>
                <div class="bar-text">Health: <span id="healthText">20/20</span></div>
            </div>
            <div class="bar">
                <div class="bar-fill hunger-fill" id="hungerBar" style="width: 100%"></div>
                <div class="bar-text">Hunger: <span id="hungerText">20/20</span></div>
            </div>
            <div style="color: white; margin-top: 10px;">
                FPS: <span id="fps">0</span> | Blocks: <span id="blockCount">0</span>
            </div>
        </div>
        
        <div id="hotbar"></div>
        
        <div id="inventory">
            <h3 style="color: white; text-align: center;">Inventory</h3>
            <div class="inventory-grid" id="inventoryGrid"></div>
            <div style="text-align: center; margin-top: 10px; color: white;">
                Press E to close
            </div>
        </div>
    </div>
    
    <div id="mobileControls">
        <div class="joystick" id="joystick">
            <div class="joystick-knob" id="joystickKnob"></div>
        </div>
    </div>
    
    <div class="mobile-buttons">
        <button class="mobile-btn" id="jumpBtn">Jump</button>
        <button class="mobile-btn" id="breakBtn">Break</button>
        <button class="mobile-btn" id="placeBtn">Place</button>
    </div>
    
    <canvas id="blockBreaking"></canvas>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Game Configuration
        const CHUNK_SIZE = 16;
        const CHUNK_HEIGHT = 32;
        const RENDER_DISTANCE = 4;
        const BLOCK_SIZE = 1;
        const GRAVITY = -20;
        const JUMP_FORCE = 8;
        const PLAYER_SPEED = 8;
        const PLAYER_HEIGHT = 1.8;
        
        // Block Types
        const BlockType = {
            AIR: 0,
            GRASS: 1,
            DIRT: 2,
            STONE: 3,
            WOOD: 4,
            LEAVES: 5,
            SAND: 6,
            WATER: 7,
            COBBLESTONE: 8,
            PLANKS: 9,
            GLASS: 10,
            COAL: 11,
            IRON: 12,
            GOLD: 13,
            DIAMOND: 14
        };
        
        const BlockData = {
            [BlockType.AIR]: { name: 'Air', color: 0x000000, transparent: true },
            [BlockType.GRASS]: { name: 'Grass', color: 0x7CFC00, drops: BlockType.DIRT },
            [BlockType.DIRT]: { name: 'Dirt', color: 0x8B4513 },
            [BlockType.STONE]: { name: 'Stone', color: 0x808080, drops: BlockType.COBBLESTONE },
            [BlockType.WOOD]: { name: 'Wood', color: 0x8B4513 },
            [BlockType.LEAVES]: { name: 'Leaves', color: 0x228B22, transparent: true },
            [BlockType.SAND]: { name: 'Sand', color: 0xF4E4C1 },
            [BlockType.WATER]: { name: 'Water', color: 0x4682B4, transparent: true },
            [BlockType.COBBLESTONE]: { name: 'Cobblestone', color: 0x696969 },
            [BlockType.PLANKS]: { name: 'Planks', color: 0xDEB887 },
            [BlockType.GLASS]: { name: 'Glass', color: 0xE0FFFF, transparent: true },
            [BlockType.COAL]: { name: 'Coal', color: 0x2F4F4F },
            [BlockType.IRON]: { name: 'Iron', color: 0xC0C0C0 },
            [BlockType.GOLD]: { name: 'Gold', color: 0xFFD700 },
            [BlockType.DIAMOND]: { name: 'Diamond', color: 0x00FFFF }
        };
        
        // Game State
        class Game {
            constructor() {
                this.scene = new THREE.Scene();
                this.scene.fog = new THREE.Fog(0x87CEEB, 10, 100);
                this.scene.background = new THREE.Color(0x87CEEB);
                
                this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                this.camera.position.set(0, 20, 0);
                
                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                document.body.appendChild(this.renderer.domElement);
                
                this.raycaster = new THREE.Raycaster();
                this.raycaster.far = 5;
                
                this.chunks = new Map();
                this.player = {
                    position: new THREE.Vector3(0, 20, 0),
                    velocity: new THREE.Vector3(0, 0, 0),
                    rotation: { x: 0, y: 0 },
                    health: 20,
                    maxHealth: 20,
                    hunger: 20,
                    maxHunger: 20,
                    onGround: false,
                    selectedBlock: BlockType.DIRT,
                    inventory: new Map(),
                    hotbar: [
                        BlockType.DIRT,
                        BlockType.STONE,
                        BlockType.WOOD,
                        BlockType.PLANKS,
                        BlockType.GLASS,
                        BlockType.SAND,
                        BlockType.LEAVES,
                        BlockType.COBBLESTONE,
                        BlockType.COAL
                    ],
                    hotbarIndex: 0
                };
                
                this.keys = {};
                this.mouse = { x: 0, y: 0, locked: false };
                this.isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
                this.joystickData = { x: 0, y: 0 };
                
                this.breakingBlock = null;
                this.breakingProgress = 0;
                this.droppedItems = [];
                
                this.setupLighting();
                this.setupControls();
                this.initInventory();
                this.generateWorld();
                this.setupUI();
                this.animate();
                
                // Auto-save every 30 seconds
                setInterval(() => this.saveWorld(), 30000);
                
                // Hunger system
                setInterval(() => {
                    if (this.player.hunger > 0) {
                        this.player.hunger = Math.max(0, this.player.hunger - 0.1);
                        this.updateStats();
                    } else if (this.player.health > 0) {
                        this.player.health = Math.max(0, this.player.health - 0.1);
                        this.updateStats();
                    }
                }, 5000);
            }
            
            setupLighting() {
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
                this.scene.add(ambientLight);
                
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight.position.set(50, 100, 50);
                directionalLight.castShadow = true;
                directionalLight.shadow.camera.left = -50;
                directionalLight.shadow.camera.right = 50;
                directionalLight.shadow.camera.top = 50;
                directionalLight.shadow.camera.bottom = -50;
                this.scene.add(directionalLight);
            }
            
            setupControls() {
                // Keyboard controls
                document.addEventListener('keydown', (e) => {
                    this.keys[e.key.toLowerCase()] = true;
                    
                    if (e.key === 'e' || e.key === 'E') {
                        this.toggleInventory();
                    }
                    
                    // Hotbar selection
                    if (e.key >= '1' && e.key <= '9') {
                        this.player.hotbarIndex = parseInt(e.key) - 1;
                        this.player.selectedBlock = this.player.hotbar[this.player.hotbarIndex];
                        this.updateHotbar();
                    }
                });
                
                document.addEventListener('keyup', (e) => {
                    this.keys[e.key.toLowerCase()] = false;
                });
                
                // Mouse controls
                this.renderer.domElement.addEventListener('click', () => {
                    if (!this.mouse.locked && !this.isMobile) {
                        this.renderer.domElement.requestPointerLock();
                    }
                });
                
                document.addEventListener('pointerlockchange', () => {
                    this.mouse.locked = document.pointerLockElement === this.renderer.domElement;
                });
                
                document.addEventListener('mousemove', (e) => {
                    if (this.mouse.locked) {
                        this.player.rotation.y -= e.movementX * 0.002;
                        this.player.rotation.x -= e.movementY * 0.002;
                        this.player.rotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, this.player.rotation.x));
                    }
                });
                
                // Block interaction
                this.renderer.domElement.addEventListener('mousedown', (e) => {
                    if (e.button === 0) { // Left click - break
                        this.startBreaking();
                    } else if (e.button === 2) { // Right click - place
                        this.placeBlock();
                    }
                });
                
                this.renderer.domElement.addEventListener('mouseup', (e) => {
                    if (e.button === 0) {
                        this.stopBreaking();
                    }
                });
                
                this.renderer.domElement.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                });
                
                // Mobile controls
                if (this.isMobile) {
                    this.setupMobileControls();
                }
                
                // Window resize
                window.addEventListener('resize', () => {
                    this.camera.aspect = window.innerWidth / window.innerHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                });
            }
            
            setupMobileControls() {
                const joystick = document.getElementById('joystick');
                const knob = document.getElementById('joystickKnob');
                let joystickActive = false;
                
                const handleJoystick = (e) => {
                    if (!joystickActive) return;
                    
                    const touch = e.touches[0];
                    const rect = joystick.getBoundingClientRect();
                    const centerX = rect.left + rect.width / 2;
                    const centerY = rect.top + rect.height / 2;
                    
                    let x = (touch.clientX - centerX) / (rect.width / 2);
                    let y = (touch.clientY - centerY) / (rect.height / 2);
                    
                    const distance = Math.sqrt(x * x + y * y);
                    if (distance > 1) {
                        x /= distance;
                        y /= distance;
                    }
                    
                    this.joystickData = { x, y };
                    knob.style.transform = `translate(calc(-50% + ${x * 40}px), calc(-50% + ${y * 40}px))`;
                };
                
                joystick.addEventListener('touchstart', (e) => {
                    joystickActive = true;
                    handleJoystick(e);
                });
                
                joystick.addEventListener('touchmove', handleJoystick);
                
                joystick.addEventListener('touchend', () => {
                    joystickActive = false;
                    this.joystickData = { x: 0, y: 0 };
                    knob.style.transform = 'translate(-50%, -50%)';
                });
                
                // Touch look controls
                let lookTouch = null;
                this.renderer.domElement.addEventListener('touchstart', (e) => {
                    if (e.touches.length === 1 && !lookTouch) {
                        lookTouch = {
                            id: e.touches[0].identifier,
                            x: e.touches[0].clientX,
                            y: e.touches[0].clientY
                        };
                    }
                });
                
                this.renderer.domElement.addEventListener('touchmove', (e) => {
                    if (lookTouch) {
                        for (let touch of e.touches) {
                            if (touch.identifier === lookTouch.id) {
                                const deltaX = touch.clientX - lookTouch.x;
                                const deltaY = touch.clientY - lookTouch.y;
                                
                                this.player.rotation.y -= deltaX * 0.005;
                                this.player.rotation.x -= deltaY * 0.005;
                                this.player.rotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, this.player.rotation.x));
                                
                                lookTouch.x = touch.clientX;
                                lookTouch.y = touch.clientY;
                                break;
                            }
                        }
                    }
                });
                
                this.renderer.domElement.addEventListener('touchend', (e) => {
                    if (lookTouch) {
                        for (let touch of e.changedTouches) {
                            if (touch.identifier === lookTouch.id) {
                                lookTouch = null;
                                break;
                            }
                        }
                    }
                });
                
                // Mobile buttons
                document.getElementById('jumpBtn').addEventListener('touchstart', () => {
                    if (this.player.onGround) {
                        this.player.velocity.y = JUMP_FORCE;
                    }
                });
                
                document.getElementById('breakBtn').addEventListener('touchstart', () => {
                    this.startBreaking();
                });
                
                document.getElementById('breakBtn').addEventListener('touchend', () => {
                    this.stopBreaking();
                });
                
                document.getElementById('placeBtn').addEventListener('touchstart', () => {
                    this.placeBlock();
                });
            }
            
            initInventory() {
                // Initialize player inventory with some starting items
                this.player.inventory.set(BlockType.DIRT, 64);
                this.player.inventory.set(BlockType.STONE, 32);
                this.player.inventory.set(BlockType.WOOD, 16);
                this.player.inventory.set(BlockType.PLANKS, 32);
                this.player.inventory.set(BlockType.GLASS, 16);
                this.player.inventory.set(BlockType.SAND, 32);
                
                this.updateHotbar();
                this.updateInventoryUI();
            }
            
            setupUI() {
                this.updateHotbar();
                this.updateStats();
                
                // FPS counter
                let frameCount = 0;
                let lastTime = performance.now();
                
                setInterval(() => {
                    const currentTime = performance.now();
                    const fps = Math.round(frameCount * 1000 / (currentTime - lastTime));
                    document.getElementById('fps').textContent = fps;
                    frameCount = 0;
                    lastTime = currentTime;
                }, 1000);
                
                this.frameCount = () => frameCount++;
            }
            
            updateHotbar() {
                const hotbarElement = document.getElementById('hotbar');
                hotbarElement.innerHTML = '';
                
                for (let i = 0; i < 9; i++) {
                    const slot = document.createElement('div');
                    slot.className = 'hotbar-slot';
                    if (i === this.player.hotbarIndex) {
                        slot.classList.add('active');
                    }
                    
                    const blockType = this.player.hotbar[i];
                    if (blockType && blockType !== BlockType.AIR) {
                        const blockData = BlockData[blockType];
                        slot.style.backgroundColor = `#${blockData.color.toString(16).padStart(6, '0')}88`;
                        slot.innerHTML = `
                            <div>${blockData.name}</div>
                            <div class="count">${this.player.inventory.get(blockType) || 0}</div>
                        `;
                    }
                    
                    hotbarElement.appendChild(slot);
                }
            }
            
            updateStats() {
                const healthPercent = (this.player.health / this.player.maxHealth) * 100;
                const hungerPercent = (this.player.hunger / this.player.maxHunger) * 100;
                
                document.getElementById('healthBar').style.width = `${healthPercent}%`;
                document.getElementById('healthText').textContent = `${Math.ceil(this.player.health)}/${this.player.maxHealth}`;
                
                document.getElementById('hungerBar').style.width = `${hungerPercent}%`;
                document.getElementById('hungerText').textContent = `${Math.ceil(this.player.hunger)}/${this.player.maxHunger}`;
            }
            
            toggleInventory() {
                const inventory = document.getElementById('inventory');
                inventory.classList.toggle('open');
                
                if (inventory.classList.contains('open')) {
                    this.updateInventoryUI();
                    if (!this.isMobile) {
                        document.exitPointerLock();
                    }
                }
            }
            
            updateInventoryUI() {
                const grid = document.getElementById('inventoryGrid');
                grid.innerHTML = '';
                
                // Add all available block types to inventory
                for (let blockType in BlockData) {
                    if (blockType == BlockType.AIR) continue;
                    
                    const slot = document.createElement('div');
                    slot.className = 'inventory-slot';
                    
                    const blockData = BlockData[blockType];
                    const count = this.player.inventory.get(parseInt(blockType)) || 0;
                    
                    slot.style.backgroundColor = `#${blockData.color.toString(16).padStart(6, '0')}88`;
                    slot.innerHTML = `
                        <div>${blockData.name}</div>
                        <div class="count">${count}</div>
                    `;
                    
                    slot.addEventListener('click', () => {
                        const index = this.player.hotbarIndex;
                        this.player.hotbar[index] = parseInt(blockType);
                        this.player.selectedBlock = parseInt(blockType);
                        this.updateHotbar();
                    });
                    
                    grid.appendChild(slot);
                }
            }
            
            generateWorld() {
                const playerChunkX = Math.floor(this.player.position.x / CHUNK_SIZE);
                const playerChunkZ = Math.floor(this.player.position.z / CHUNK_SIZE);
                
                for (let x = -RENDER_DISTANCE; x <= RENDER_DISTANCE; x++) {
                    for (let z = -RENDER_DISTANCE; z <= RENDER_DISTANCE; z++) {
                        const chunkX = playerChunkX + x;
                        const chunkZ = playerChunkZ + z;
                        const chunkKey = `${chunkX},${chunkZ}`;
                        
                        if (!this.chunks.has(chunkKey)) {
                            this.generateChunk(chunkX, chunkZ);
                        }
                    }
                }
                
                // Remove far chunks
                for (let [key, chunk] of this.chunks) {
                    const [cx, cz] = key.split(',').map(Number);
                    const distance = Math.max(
                        Math.abs(cx - playerChunkX),
                        Math.abs(cz - playerChunkZ)
                    );
                    
                    if (distance > RENDER_DISTANCE + 1) {
                        this.scene.remove(chunk.mesh);
                        this.chunks.delete(key);
                    }
                }
                
                document.getElementById('blockCount').textContent = this.chunks.size * CHUNK_SIZE * CHUNK_SIZE * 10;
            }
            
            generateChunk(chunkX, chunkZ) {
                const chunkKey = `${chunkX},${chunkZ}`;
                const blocks = new Uint8Array(CHUNK_SIZE * CHUNK_HEIGHT * CHUNK_SIZE);
                
                // Simple terrain generation
                for (let x = 0; x < CHUNK_SIZE; x++) {
                    for (let z = 0; z < CHUNK_SIZE; z++) {
                        const worldX = chunkX * CHUNK_SIZE + x;
                        const worldZ = chunkZ * CHUNK_SIZE + z;
                        
                        // Height map using simple noise
                        const height = Math.floor(10 + 
                            Math.sin(worldX * 0.1) * 3 + 
                            Math.cos(worldZ * 0.1) * 3 +
                            Math.sin(worldX * 0.05) * 5
                        );
                        
                        for (let y = 0; y < CHUNK_HEIGHT; y++) {
                            const index = x + y * CHUNK_SIZE + z * CHUNK_SIZE * CHUNK_HEIGHT;
                            
                            if (y < height - 3) {
                                blocks[index] = BlockType.STONE;
                            } else if (y < height) {
                                blocks[index] = BlockType.DIRT;
                            } else if (y === height) {
                                blocks[index] = BlockType.GRASS;
                            }
                            
                            // Add some ores
                            if (y < height - 5 && Math.random() < 0.02) {
                                const oreRoll = Math.random();
                                if (oreRoll < 0.01) {
                                    blocks[index] = BlockType.DIAMOND;
                                } else if (oreRoll < 0.03) {
                                    blocks[index] = BlockType.GOLD;
                                } else if (oreRoll < 0.08) {
                                    blocks[index] = BlockType.IRON;
                                } else {
                                    blocks[index] = BlockType.COAL;
                                }
                            }
                        }
                        
                        // Add trees randomly
                        if (Math.random() < 0.01 && blocks[x + height * CHUNK_SIZE + z * CHUNK_SIZE * CHUNK_HEIGHT] === BlockType.GRASS) {
                            this.generateTree(blocks, x, height + 1, z);
                        }
                    }
                }
                
                const chunk = {
                    x: chunkX,
                    z: chunkZ,
                    blocks: blocks,
                    mesh: null,
                    dirty: true
                };
                
                this.chunks.set(chunkKey, chunk);
                this.updateChunkMesh(chunk);
            }
            
            generateTree(blocks, x, y, z) {
                // Tree trunk
                for (let h = 0; h < 5; h++) {
                    if (y + h < CHUNK_HEIGHT) {
                        const index = x + (y + h) * CHUNK_SIZE + z * CHUNK_SIZE * CHUNK_HEIGHT;
                        blocks[index] = BlockType.WOOD;
                    }
                }
                
                // Leaves
                for (let lx = -2; lx <= 2; lx++) {
                    for (let ly = 3; ly <= 5; ly++) {
                        for (let lz = -2; lz <= 2; lz++) {
                            const nx = x + lx;
                            const ny = y + ly;
                            const nz = z + lz;
                            
                            if (nx >= 0 && nx < CHUNK_SIZE && 
                                ny >= 0 && ny < CHUNK_HEIGHT && 
                                nz >= 0 && nz < CHUNK_SIZE) {
                                
                                const index = nx + ny * CHUNK_SIZE + nz * CHUNK_SIZE * CHUNK_HEIGHT;
                                if (blocks[index] === BlockType.AIR) {
                                    blocks[index] = BlockType.LEAVES;
                                }
                            }
                        }
                    }
                }
            }
            
            updateChunkMesh(chunk) {
                if (chunk.mesh) {
                    this.scene.remove(chunk.mesh);
                    chunk.mesh.geometry.dispose();
                }
                
                const geometry = new THREE.BufferGeometry();
                const vertices = [];
                const colors = [];
                const normals = [];
                
                // Simple meshing (not optimized greedy meshing for simplicity)
                for (let x = 0; x < CHUNK_SIZE; x++) {
                    for (let y = 0; y < CHUNK_HEIGHT; y++) {
                        for (let z = 0; z < CHUNK_SIZE; z++) {
                            const index = x + y * CHUNK_SIZE + z * CHUNK_SIZE * CHUNK_HEIGHT;
                            const block = chunk.blocks[index];
                            
                            if (block !== BlockType.AIR) {
                                const worldX = chunk.x * CHUNK_SIZE + x;
                                const worldZ = chunk.z * CHUNK_SIZE + z;
                                
                                // Check each face
                                const faces = [
                                    { dir: [0, 1, 0], normal: [0, 1, 0] },   // top
                                    { dir: [0, -1, 0], normal: [0, -1, 0] }, // bottom
                                    { dir: [1, 0, 0], normal: [1, 0, 0] },   // right
                                    { dir: [-1, 0, 0], normal: [-1, 0, 0] }, // left
                                    { dir: [0, 0, 1], normal: [0, 0, 1] },   // front
                                    { dir: [0, 0, -1], normal: [0, 0, -1] }  // back
                                ];
                                
                                for (let face of faces) {
                                    const nx = x + face.dir[0];
                                    const ny = y + face.dir[1];
                                    const nz = z + face.dir[2];
                                    
                                    let neighborBlock = BlockType.AIR;
                                    
                                    if (nx >= 0 && nx < CHUNK_SIZE && 
                                        ny >= 0 && ny < CHUNK_HEIGHT && 
                                        nz >= 0 && nz < CHUNK_SIZE) {
                                        const nIndex = nx + ny * CHUNK_SIZE + nz * CHUNK_SIZE * CHUNK_HEIGHT;
                                        neighborBlock = chunk.blocks[nIndex];
                                    }
                                    
                                    if (neighborBlock === BlockType.AIR || BlockData[neighborBlock].transparent) {
                                        this.addFace(vertices, colors, normals, worldX, y, worldZ, face.normal, BlockData[block].color);
                                    }
                                }
                            }
                        }
                    }
                }
                
                geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
                geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
                geometry.setAttribute('normal', new THREE.Float32BufferAttribute(normals, 3));
                
                const material = new THREE.MeshLambertMaterial({ 
                    vertexColors: true,
                    side: THREE.FrontSide
                });
                
                chunk.mesh = new THREE.Mesh(geometry, material);
                chunk.mesh.castShadow = true;
                chunk.mesh.receiveShadow = true;
                this.scene.add(chunk.mesh);
                
                chunk.dirty = false;
            }
            
            addFace(vertices, colors, normals, x, y, z, normal, color) {
                const r = ((color >> 16) & 255) / 255;
                const g = ((color >> 8) & 255) / 255;
                const b = (color & 255) / 255;
                
                // Adjust color based on face normal for simple shading
                let brightness = 1.0;
                if (normal[1] === -1) brightness = 0.5; // bottom
                else if (normal[1] === 0) brightness = 0.8; // sides
                
                const positions = {
                    '[0,1,0]': [ // top
                        [x - 0.5, y + 0.5, z - 0.5], [x + 0.5, y + 0.5, z - 0.5],
                        [x + 0.5, y + 0.5, z + 0.5], [x - 0.5, y + 0.5, z + 0.5]
                    ],
                    '[0,-1,0]': [ // bottom
                        [x - 0.5, y - 0.5, z - 0.5], [x - 0.5, y - 0.5, z + 0.5],
                        [x + 0.5, y - 0.5, z + 0.5], [x + 0.5, y - 0.5, z - 0.5]
                    ],
                    '[1,0,0]': [ // right
                        [x + 0.5, y - 0.5, z - 0.5], [x + 0.5, y - 0.5, z + 0.5],
                        [x + 0.5, y + 0.5, z + 0.5], [x + 0.5, y + 0.5, z - 0.5]
                    ],
                    '[-1,0,0]': [ // left
                        [x - 0.5, y - 0.5, z - 0.5], [x - 0.5, y + 0.5, z - 0.5],
                        [x - 0.5, y + 0.5, z + 0.5], [x - 0.5, y - 0.5, z + 0.5]
                    ],
                    '[0,0,1]': [ // front
                        [x - 0.5, y - 0.5, z + 0.5], [x - 0.5, y + 0.5, z + 0.5],
                        [x + 0.5, y + 0.5, z + 0.5], [x + 0.5, y - 0.5, z + 0.5]
                    ],
                    '[0,0,-1]': [ // back
                        [x - 0.5, y - 0.5, z - 0.5], [x + 0.5, y - 0.5, z - 0.5],
                        [x + 0.5, y + 0.5, z - 0.5], [x - 0.5, y + 0.5, z - 0.5]
                    ]
                };
                
                const faceVerts = positions[JSON.stringify(normal)];
                
                // Two triangles per face
                const indices = [0, 1, 2, 0, 2, 3];
                for (let i of indices) {
                    vertices.push(...faceVerts[i]);
                    colors.push(r * brightness, g * brightness, b * brightness);
                    normals.push(...normal);
                }
            }
            
            getBlock(x, y, z) {
                const chunkX = Math.floor(x / CHUNK_SIZE);
                const chunkZ = Math.floor(z / CHUNK_SIZE);
                const chunkKey = `${chunkX},${chunkZ}`;
                
                const chunk = this.chunks.get(chunkKey);
                if (!chunk) return BlockType.AIR;
                
                const localX = ((x % CHUNK_SIZE) + CHUNK_SIZE) % CHUNK_SIZE;
                const localZ = ((z % CHUNK_SIZE) + CHUNK_SIZE) % CHUNK_SIZE;
                
                if (y < 0 || y >= CHUNK_HEIGHT) return BlockType.AIR;
                
                const index = localX + y * CHUNK_SIZE + localZ * CHUNK_SIZE * CHUNK_HEIGHT;
                return chunk.blocks[index];
            }
            
            setBlock(x, y, z, blockType) {
                const chunkX = Math.floor(x / CHUNK_SIZE);
                const chunkZ = Math.floor(z / CHUNK_SIZE);
                const chunkKey = `${chunkX},${chunkZ}`;
                
                const chunk = this.chunks.get(chunkKey);
                if (!chunk) return;
                
                const localX = ((x % CHUNK_SIZE) + CHUNK_SIZE) % CHUNK_SIZE;
                const localZ = ((z % CHUNK_SIZE) + CHUNK_SIZE) % CHUNK_SIZE;
                
                if (y < 0 || y >= CHUNK_HEIGHT) return;
                
                const index = localX + y * CHUNK_SIZE + localZ * CHUNK_SIZE * CHUNK_HEIGHT;
                chunk.blocks[index] = blockType;
                chunk.dirty = true;
                
                this.updateChunkMesh(chunk);
                
                // Update adjacent chunks if on border
                if (localX === 0) this.updateAdjacentChunk(chunkX - 1, chunkZ);
                if (localX === CHUNK_SIZE - 1) this.updateAdjacentChunk(chunkX + 1, chunkZ);
                if (localZ === 0) this.updateAdjacentChunk(chunkX, chunkZ - 1);
                if (localZ === CHUNK_SIZE - 1) this.updateAdjacentChunk(chunkX, chunkZ + 1);
            }
            
            updateAdjacentChunk(chunkX, chunkZ) {
                const chunkKey = `${chunkX},${chunkZ}`;
                const chunk = this.chunks.get(chunkKey);
                if (chunk) {
                    this.updateChunkMesh(chunk);
                }
            }
            
            raycastBlock() {
                const direction = new THREE.Vector3(0, 0, -1);
                direction.applyQuaternion(this.camera.quaternion);
                
                this.raycaster.set(this.camera.position, direction);
                
                // Check for block intersection
                for (let distance = 0.5; distance < 5; distance += 0.1) {
                    const point = this.camera.position.clone().add(direction.clone().multiplyScalar(distance));
                    const x = Math.floor(point.x + 0.5);
                    const y = Math.floor(point.y + 0.5);
                    const z = Math.floor(point.z + 0.5);
                    
                    const block = this.getBlock(x, y, z);
                    if (block !== BlockType.AIR) {
                        // Find which face was hit
                        const prevPoint = this.camera.position.clone().add(direction.clone().multiplyScalar(distance - 0.1));
                        const px = Math.floor(prevPoint.x + 0.5);
                        const py = Math.floor(prevPoint.y + 0.5);
                        const pz = Math.floor(prevPoint.z + 0.5);
                        
                        let face = null;
                        if (px !== x) face = { x: x - px, y: 0, z: 0 };
                        else if (py !== y) face = { x: 0, y: y - py, z: 0 };
                        else if (pz !== z) face = { x: 0, y: 0, z: z - pz };
                        
                        return { x, y, z, face, block };
                    }
                }
                
                return null;
            }
            
            startBreaking() {
                const hit = this.raycastBlock();
                if (hit) {
                    this.breakingBlock = hit;
                    this.breakingProgress = 0;
                }
            }
            
            stopBreaking() {
                if (this.breakingBlock && this.breakingProgress >= 1) {
                    this.breakBlock(this.breakingBlock.x, this.breakingBlock.y, this.breakingBlock.z);
                }
                this.breakingBlock = null;
                this.breakingProgress = 0;
            }
            
            breakBlock(x, y, z) {
                const blockType = this.getBlock(x, y, z);
                if (blockType === BlockType.AIR) return;
                
                const blockData = BlockData[blockType];
                const dropType = blockData.drops !== undefined ? blockData.drops : blockType;
                
                // Add to inventory
                const currentCount = this.player.inventory.get(dropType) || 0;
                this.player.inventory.set(dropType, currentCount + 1);
                
                // Create drop animation
                this.createDropAnimation(x, y, z, dropType);
                
                // Remove block
                this.setBlock(x, y, z, BlockType.AIR);
                
                // Update UI
                this.updateHotbar();
                this.updateInventoryUI();
                
                // Restore some hunger
                this.player.hunger = Math.min(this.player.maxHunger, this.player.hunger + 0.5);
                this.updateStats();
            }
            
            createDropAnimation(x, y, z, blockType) {
                const geometry = new THREE.BoxGeometry(0.3, 0.3, 0.3);
                const material = new THREE.MeshBasicMaterial({ 
                    color: BlockData[blockType].color 
                });
                const mesh = new THREE.Mesh(geometry, material);
                
                mesh.position.set(x, y, z);
                mesh.userData = { 
                    velocity: new THREE.Vector3(
                        (Math.random() - 0.5) * 2,
                        Math.random() * 3 + 2,
                        (Math.random() - 0.5) * 2
                    ),
                    blockType: blockType,
                    time: 0
                };
                
                this.scene.add(mesh);
                this.droppedItems.push(mesh);
            }
            
            updateDroppedItems(deltaTime) {
                for (let i = this.droppedItems.length - 1; i >= 0; i--) {
                    const item = this.droppedItems[i];
                    item.userData.time += deltaTime;
                    
                    // Physics
                    item.userData.velocity.y += GRAVITY * deltaTime;
                    item.position.add(item.userData.velocity.clone().multiplyScalar(deltaTime));
                    
                    // Rotation
                    item.rotation.y += deltaTime * 2;
                    
                    // Check if player picks it up
                    const distance = item.position.distanceTo(this.player.position);
                    if (distance < 1.5) {
                        const blockType = item.userData.blockType;
                        const currentCount = this.player.inventory.get(blockType) || 0;
                        this.player.inventory.set(blockType, currentCount + 1);
                        
                        this.scene.remove(item);
                        this.droppedItems.splice(i, 1);
                        
                        this.updateHotbar();
                        this.updateInventoryUI();
                        continue;
                    }
                    
                    // Remove after 30 seconds
                    if (item.userData.time > 30) {
                        this.scene.remove(item);
                        this.droppedItems.splice(i, 1);
                    }
                }
            }
            
            placeBlock() {
                const hit = this.raycastBlock();
                if (!hit || !hit.face) return;
                
                const blockType = this.player.selectedBlock;
                const count = this.player.inventory.get(blockType) || 0;
                
                if (count <= 0) return;
                
                const newX = hit.x + hit.face.x;
                const newY = hit.y + hit.face.y;
                const newZ = hit.z + hit.face.z;
                
                // Check if block would intersect with player
                const playerBox = {
                    minX: this.player.position.x - 0.3,
                    maxX: this.player.position.x + 0.3,
                    minY: this.player.position.y - PLAYER_HEIGHT / 2,
                    maxY: this.player.position.y + PLAYER_HEIGHT / 2,
                    minZ: this.player.position.z - 0.3,
                    maxZ: this.player.position.z + 0.3
                };
                
                const blockBox = {
                    minX: newX - 0.5,
                    maxX: newX + 0.5,
                    minY: newY - 0.5,
                    maxY: newY + 0.5,
                    minZ: newZ - 0.5,
                    maxZ: newZ + 0.5
                };
                
                if (this.boxesIntersect(playerBox, blockBox)) return;
                
                // Place block
                this.setBlock(newX, newY, newZ, blockType);
                
                // Decrease inventory
                this.player.inventory.set(blockType, count - 1);
                this.updateHotbar();
                this.updateInventoryUI();
            }
            
            boxesIntersect(a, b) {
                return a.minX < b.maxX && a.maxX > b.minX &&
                       a.minY < b.maxY && a.maxY > b.minY &&
                       a.minZ < b.maxZ && a.maxZ > b.minZ;
            }
            
            updatePlayer(deltaTime) {
                // Movement
                const moveVector = new THREE.Vector3();
                
                if (this.isMobile) {
                    // Mobile joystick movement
                    moveVector.x = this.joystickData.x;
                    moveVector.z = this.joystickData.y;
                } else {
                    // Keyboard movement
                    if (this.keys['w']) moveVector.z -= 1;
                    if (this.keys['s']) moveVector.z += 1;
                    if (this.keys['a']) moveVector.x -= 1;
                    if (this.keys['d']) moveVector.x += 1;
                }
                
                if (moveVector.length() > 0) {
                    moveVector.normalize();
                    moveVector.applyAxisAngle(new THREE.Vector3(0, 1, 0), this.player.rotation.y);
                    moveVector.multiplyScalar(PLAYER_SPEED * deltaTime);
                    
                    // Check collision for X movement
                    const newPosX = this.player.position.clone();
                    newPosX.x += moveVector.x;
                    if (!this.checkCollision(newPosX)) {
                        this.player.position.x += moveVector.x;
                    }
                    
                    // Check collision for Z movement
                    const newPosZ = this.player.position.clone();
                    newPosZ.z += moveVector.z;
                    if (!this.checkCollision(newPosZ)) {
                        this.player.position.z += moveVector.z;
                    }
                }
                
                // Jump
                if ((this.keys[' '] || this.keys['space']) && this.player.onGround) {
                    this.player.velocity.y = JUMP_FORCE;
                }
                
                // Gravity
                this.player.velocity.y += GRAVITY * deltaTime;
                
                // Apply vertical movement
                const newPosY = this.player.position.clone();
                newPosY.y += this.player.velocity.y * deltaTime;
                
                if (this.checkCollision(newPosY)) {
                    if (this.player.velocity.y < 0) {
                        this.player.onGround = true;
                        
                        // Fall damage
                        if (this.player.velocity.y < -15) {
                            const damage = Math.floor(Math.abs(this.player.velocity.y) - 15);
                            this.player.health = Math.max(0, this.player.health - damage);
                            this.updateStats();
                        }
                    }
                    this.player.velocity.y = 0;
                } else {
                    this.player.position.y += this.player.velocity.y * deltaTime;
                    this.player.onGround = false;
                }
                
                // Update camera
                this.camera.position.copy(this.player.position);
                this.camera.position.y += PLAYER_HEIGHT / 2 - 0.2;
                
                this.camera.rotation.x = this.player.rotation.x;
                this.camera.rotation.y = this.player.rotation.y;
                
                // Death check
                if (this.player.position.y < -50 || this.player.health <= 0) {
                    this.respawn();
                }
            }
            
            checkCollision(position) {
                const margin = 0.3;
                const height = PLAYER_HEIGHT;
                
                // Check multiple points around the player
                const checkPoints = [
                    { x: position.x - margin, y: position.y, z: position.z - margin },
                    { x: position.x + margin, y: position.y, z: position.z - margin },
                    { x: position.x - margin, y: position.y, z: position.z + margin },
                    { x: position.x + margin, y: position.y, z: position.z + margin },
                    { x: position.x, y: position.y - height/2, z: position.z },
                    { x: position.x, y: position.y + height/2, z: position.z }
                ];
                
                for (let point of checkPoints) {
                    const block = this.getBlock(
                        Math.floor(point.x + 0.5),
                        Math.floor(point.y + 0.5),
                        Math.floor(point.z + 0.5)
                    );
                    
                    if (block !== BlockType.AIR && !BlockData[block].transparent) {
                        return true;
                    }
                }
                
                return false;
            }
            
            respawn() {
                this.player.position.set(0, 30, 0);
                this.player.velocity.set(0, 0, 0);
                this.player.health = this.player.maxHealth;
                this.player.hunger = this.player.maxHunger;
                this.updateStats();
            }
            
            saveWorld() {
                const saveData = {
                    player: {
                        position: this.player.position.toArray(),
                        rotation: { x: this.player.rotation.x, y: this.player.rotation.y },
                        health: this.player.health,
                        hunger: this.player.hunger,
                        inventory: Array.from(this.player.inventory.entries()),
                        hotbar: this.player.hotbar
                    },
                    chunks: {}
                };
                
                for (let [key, chunk] of this.chunks) {
                    saveData.chunks[key] = Array.from(chunk.blocks);
                }
                
                localStorage.setItem('webcraft_save', JSON.stringify(saveData));
                console.log('World saved!');
            }
            
            loadWorld() {
                const saveDataStr = localStorage.getItem('webcraft_save');
                if (!saveDataStr) return false;
                
                try {
                    const saveData = JSON.parse(saveDataStr);
                    
                    // Load player data
                    this.player.position.fromArray(saveData.player.position);
                    this.player.rotation = saveData.player.rotation;
                    this.player.health = saveData.player.health;
                    this.player.hunger = saveData.player.hunger;
                    this.player.inventory = new Map(saveData.player.inventory);
                    this.player.hotbar = saveData.player.hotbar;
                    
                    // Load chunks
                    for (let key in saveData.chunks) {
                        const [x, z] = key.split(',').map(Number);
                        const chunk = {
                            x: x,
                            z: z,
                            blocks: new Uint8Array(saveData.chunks[key]),
                            mesh: null,
                            dirty: true
                        };
                        this.chunks.set(key, chunk);
                        this.updateChunkMesh(chunk);
                    }
                    
                    this.updateStats();
                    this.updateHotbar();
                    console.log('World loaded!');
                    return true;
                } catch (e) {
                    console.error('Failed to load world:', e);
                    return false;
                }
            }
            
            animate() {
                requestAnimationFrame(() => this.animate());
                
                const currentTime = performance.now();
                const deltaTime = Math.min((currentTime - (this.lastTime || currentTime)) / 1000, 0.1);
                this.lastTime = currentTime;
                
                this.updatePlayer(deltaTime);
                this.generateWorld();
                this.updateDroppedItems(deltaTime);
                
                // Update breaking animation
                if (this.breakingBlock) {
                    this.breakingProgress += deltaTime * 2; // Breaking speed
                    
                    if (this.breakingProgress >= 1) {
                        this.stopBreaking();
                    }
                }
                
                // Update day/night cycle
                const dayTime = (currentTime / 1000) * 0.01;
                const sunAngle = dayTime * Math.PI * 2;
                const sunHeight = Math.sin(sunAngle);
                
                // Update lighting based on time
                this.scene.fog.color.setHSL(0.6, 0.5, 0.3 + sunHeight * 0.4);
                this.scene.background.setHSL(0.6, 0.5, 0.3 + sunHeight * 0.4);
                
                this.renderer.render(this.scene, this.camera);
                this.frameCount();
            }
        }
        
        // Start the game
        const game = new Game();
        
        // Try to load saved world
        if (!game.loadWorld()) {
            console.log('No save found, generating new world...');
        }
        
        // Save on page unload
        window.addEventListener('beforeunload', () => {
            game.saveWorld();
        });
        
        // Keyboard shortcut info
        console.log(`
WebCraft Controls:
- WASD: Move
- Space: Jump
- Mouse: Look around
- Left Click: Break blocks
- Right Click: Place blocks
- E: Open/Close inventory
- 1-9: Select hotbar item
- Mobile: Use on-screen controls
        `);
    </script>
</body>
</html>