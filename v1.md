<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebCraft - Minecraft Clone</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            overflow: hidden;
            font-family: 'Courier New', monospace;
            user-select: none;
        }

        #gameCanvas {
            display: block;
        }

        #crosshair {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            pointer-events: none;
            z-index: 100;
        }

        #crosshair::before,
        #crosshair::after {
            content: '';
            position: absolute;
            background: white;
            box-shadow: 0 0 2px black;
        }

        #crosshair::before {
            width: 100%;
            height: 2px;
            top: 50%;
            transform: translateY(-50%);
        }

        #crosshair::after {
            width: 2px;
            height: 100%;
            left: 50%;
            transform: translateX(-50%);
        }

        #hotbar {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 5px;
            z-index: 50;
        }

        .hotbar-slot {
            width: 50px;
            height: 50px;
            border: 3px solid #444;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 10px;
            position: relative;
        }

        .hotbar-slot.active {
            border-color: white;
            box-shadow: 0 0 10px white;
        }

        .hotbar-slot .block-preview {
            width: 30px;
            height: 30px;
        }

        .hotbar-number {
            position: absolute;
            top: 2px;
            left: 4px;
            font-size: 12px;
            color: white;
            text-shadow: 1px 1px 2px black;
        }

        #info {
            position: fixed;
            top: 10px;
            left: 10px;
            color: white;
            text-shadow: 2px 2px 4px black;
            font-size: 14px;
            z-index: 50;
        }

        #controls {
            position: fixed;
            top: 10px;
            right: 10px;
            color: white;
            text-shadow: 2px 2px 4px black;
            font-size: 12px;
            text-align: right;
            z-index: 50;
            background: rgba(0, 0, 0, 0.3);
            padding: 10px;
            border-radius: 5px;
        }

        #startScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 200;
            transition: opacity 0.5s;
        }

        #startScreen h1 {
            color: white;
            font-size: 48px;
            margin-bottom: 20px;
            text-shadow: 3px 3px 6px rgba(0,0,0,0.5);
        }

        #startBtn {
            padding: 15px 40px;
            font-size: 20px;
            background: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: transform 0.2s;
        }

        #startBtn:hover {
            transform: scale(1.1);
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <div id="crosshair"></div>
    
    <div id="hotbar"></div>
    
    <div id="info">
        <div>Position: <span id="position">0, 0, 0</span></div>
        <div>Chunks: <span id="chunks">0</span></div>
        <div>FPS: <span id="fps">0</span></div>
    </div>
    
    <div id="controls">
        <div><strong>Controls:</strong></div>
        <div>WASD - Move</div>
        <div>Mouse - Look</div>
        <div>Space - Jump</div>
        <div>Shift - Sprint</div>
        <div>Left Click - Break</div>
        <div>Right Click - Place</div>
        <div>1-9 - Select Block</div>
        <div>E - Save World</div>
        <div>R - Load World</div>
    </div>
    
    <div id="startScreen">
        <h1>WebCraft</h1>
        <button id="startBtn">Click to Start</button>
        <p style="color: white; margin-top: 20px;">A Minecraft-like game in pure JavaScript</p>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Block types enum
        const BlockType = {
            AIR: 0,
            GRASS: 1,
            DIRT: 2,
            STONE: 3,
            WOOD: 4,
            LEAVES: 5,
            SAND: 6,
            WATER: 7,
            PLANKS: 8,
            COBBLESTONE: 9
        };

        // Block properties
        const BlockData = {
            [BlockType.AIR]: { name: 'Air', color: null, solid: false },
            [BlockType.GRASS]: { name: 'Grass', color: 0x7EC850, solid: true },
            [BlockType.DIRT]: { name: 'Dirt', color: 0x8B5A3C, solid: true },
            [BlockType.STONE]: { name: 'Stone', color: 0x808080, solid: true },
            [BlockType.WOOD]: { name: 'Wood', color: 0x654321, solid: true },
            [BlockType.LEAVES]: { name: 'Leaves', color: 0x2D5016, solid: true },
            [BlockType.SAND]: { name: 'Sand', color: 0xF4E4BC, solid: true },
            [BlockType.WATER]: { name: 'Water', color: 0x006994, solid: false },
            [BlockType.PLANKS]: { name: 'Planks', color: 0x9B7653, solid: true },
            [BlockType.COBBLESTONE]: { name: 'Cobblestone', color: 0x5A5A5A, solid: true }
        };

        // Simple noise function for terrain generation
        class SimplexNoise {
            constructor(seed = Math.random()) {
                this.seed = seed;
                this.perm = [];
                for (let i = 0; i < 256; i++) {
                    this.perm[i] = i;
                }
                for (let i = 255; i > 0; i--) {
                    const j = Math.floor((seed * 1000000 + i) % (i + 1));
                    [this.perm[i], this.perm[j]] = [this.perm[j], this.perm[i]];
                }
                for (let i = 0; i < 256; i++) {
                    this.perm[256 + i] = this.perm[i];
                }
            }

            noise2D(x, y) {
                // Simple interpolated noise
                const X = Math.floor(x) & 255;
                const Y = Math.floor(y) & 255;
                x -= Math.floor(x);
                y -= Math.floor(y);
                const u = this.fade(x);
                const v = this.fade(y);
                
                const a = this.perm[X] + Y;
                const aa = this.perm[a];
                const ab = this.perm[a + 1];
                const b = this.perm[X + 1] + Y;
                const ba = this.perm[b];
                const bb = this.perm[b + 1];

                return this.lerp(v,
                    this.lerp(u, this.grad(this.perm[aa], x, y),
                        this.grad(this.perm[ba], x - 1, y)),
                    this.lerp(u, this.grad(this.perm[ab], x, y - 1),
                        this.grad(this.perm[bb], x - 1, y - 1))
                );
            }

            fade(t) {
                return t * t * t * (t * (t * 6 - 15) + 10);
            }

            lerp(t, a, b) {
                return a + t * (b - a);
            }

            grad(hash, x, y) {
                const h = hash & 3;
                const u = h < 2 ? x : y;
                const v = h < 2 ? y : x;
                return ((h & 1) === 0 ? u : -u) + ((h & 2) === 0 ? v : -v);
            }
        }

        // Chunk class
        class Chunk {
            constructor(x, z, world) {
                this.x = x;
                this.z = z;
                this.world = world;
                this.size = 16;
                this.height = 64;
                this.blocks = new Uint8Array(this.size * this.height * this.size);
                this.mesh = null;
                this.dirty = true;
            }

            getBlock(x, y, z) {
                if (x < 0 || x >= this.size || y < 0 || y >= this.height || z < 0 || z >= this.size) {
                    return BlockType.AIR;
                }
                return this.blocks[x + z * this.size + y * this.size * this.size];
            }

            setBlock(x, y, z, type) {
                if (x < 0 || x >= this.size || y < 0 || y >= this.height || z < 0 || z >= this.size) {
                    return;
                }
                this.blocks[x + z * this.size + y * this.size * this.size] = type;
                this.dirty = true;
            }

            generate() {
                const noise = this.world.noise;
                for (let x = 0; x < this.size; x++) {
                    for (let z = 0; z < this.size; z++) {
                        const worldX = this.x * this.size + x;
                        const worldZ = this.z * this.size + z;
                        
                        // Generate height using noise
                        const scale = 0.05;
                        const octave1 = noise.noise2D(worldX * scale, worldZ * scale) * 10;
                        const octave2 = noise.noise2D(worldX * scale * 2, worldZ * scale * 2) * 5;
                        const octave3 = noise.noise2D(worldX * scale * 4, worldZ * scale * 4) * 2;
                        
                        const height = Math.floor(20 + octave1 + octave2 + octave3);
                        
                        for (let y = 0; y < this.height; y++) {
                            let blockType = BlockType.AIR;
                            
                            if (y < height - 3) {
                                blockType = BlockType.STONE;
                            } else if (y < height - 1) {
                                blockType = BlockType.DIRT;
                            } else if (y === height - 1) {
                                blockType = BlockType.GRASS;
                            }
                            
                            this.setBlock(x, y, z, blockType);
                        }
                        
                        // Add trees randomly
                        if (Math.random() < 0.01 && this.getBlock(x, height, z) === BlockType.AIR) {
                            this.generateTree(x, height, z);
                        }
                    }
                }
            }

            generateTree(x, y, z) {
                // Simple tree generation
                const treeHeight = 4 + Math.floor(Math.random() * 3);
                
                // Trunk
                for (let i = 0; i < treeHeight; i++) {
                    this.setBlock(x, y + i, z, BlockType.WOOD);
                }
                
                // Leaves
                for (let dx = -2; dx <= 2; dx++) {
                    for (let dz = -2; dz <= 2; dz++) {
                        for (let dy = treeHeight - 2; dy <= treeHeight + 1; dy++) {
                            if (Math.abs(dx) + Math.abs(dz) <= 3) {
                                if (this.getBlock(x + dx, y + dy, z + dz) === BlockType.AIR) {
                                    this.setBlock(x + dx, y + dy, z + dz, BlockType.LEAVES);
                                }
                            }
                        }
                    }
                }
            }

            buildMesh() {
                const geometry = new THREE.BufferGeometry();
                const vertices = [];
                const colors = [];
                const normals = [];
                
                // Greedy meshing would go here for optimization
                // For now, using simple face culling
                
                for (let x = 0; x < this.size; x++) {
                    for (let y = 0; y < this.height; y++) {
                        for (let z = 0; z < this.size; z++) {
                            const block = this.getBlock(x, y, z);
                            if (block === BlockType.AIR) continue;
                            
                            const blockData = BlockData[block];
                            const color = new THREE.Color(blockData.color);
                            
                            // Check each face
                            const worldX = this.x * this.size + x;
                            const worldY = y;
                            const worldZ = this.z * this.size + z;
                            
                            // Right face (+X)
                            if (this.shouldRenderFace(x + 1, y, z)) {
                                this.addFace(vertices, colors, normals, worldX, worldY, worldZ, 0, color);
                            }
                            // Left face (-X)
                            if (this.shouldRenderFace(x - 1, y, z)) {
                                this.addFace(vertices, colors, normals, worldX, worldY, worldZ, 1, color);
                            }
                            // Top face (+Y)
                            if (this.shouldRenderFace(x, y + 1, z)) {
                                this.addFace(vertices, colors, normals, worldX, worldY, worldZ, 2, color);
                            }
                            // Bottom face (-Y)
                            if (this.shouldRenderFace(x, y - 1, z)) {
                                this.addFace(vertices, colors, normals, worldX, worldY, worldZ, 3, color);
                            }
                            // Front face (+Z)
                            if (this.shouldRenderFace(x, y, z + 1)) {
                                this.addFace(vertices, colors, normals, worldX, worldY, worldZ, 4, color);
                            }
                            // Back face (-Z)
                            if (this.shouldRenderFace(x, y, z - 1)) {
                                this.addFace(vertices, colors, normals, worldX, worldY, worldZ, 5, color);
                            }
                        }
                    }
                }
                
                geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
                geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
                geometry.setAttribute('normal', new THREE.Float32BufferAttribute(normals, 3));
                
                const material = new THREE.MeshLambertMaterial({ 
                    vertexColors: true,
                    side: THREE.FrontSide
                });
                
                if (this.mesh) {
                    this.world.scene.remove(this.mesh);
                    this.mesh.geometry.dispose();
                    this.mesh.material.dispose();
                }
                
                this.mesh = new THREE.Mesh(geometry, material);
                this.world.scene.add(this.mesh);
                this.dirty = false;
            }

            shouldRenderFace(x, y, z) {
                if (y < 0) return false;
                if (y >= this.height) return true;
                
                const block = this.getBlock(x, y, z);
                return block === BlockType.AIR || !BlockData[block].solid;
            }

            addFace(vertices, colors, normals, x, y, z, face, color) {
                const positions = [
                    // Right face (+X)
                    [
                        [x + 1, y, z], [x + 1, y + 1, z], [x + 1, y + 1, z + 1],
                        [x + 1, y, z], [x + 1, y + 1, z + 1], [x + 1, y, z + 1]
                    ],
                    // Left face (-X)
                    [
                        [x, y, z], [x, y + 1, z + 1], [x, y + 1, z],
                        [x, y, z], [x, y, z + 1], [x, y + 1, z + 1]
                    ],
                    // Top face (+Y)
                    [
                        [x, y + 1, z], [x + 1, y + 1, z + 1], [x + 1, y + 1, z],
                        [x, y + 1, z], [x, y + 1, z + 1], [x + 1, y + 1, z + 1]
                    ],
                    // Bottom face (-Y)
                    [
                        [x, y, z], [x + 1, y, z], [x + 1, y, z + 1],
                        [x, y, z], [x + 1, y, z + 1], [x, y, z + 1]
                    ],
                    // Front face (+Z)
                    [
                        [x, y, z + 1], [x + 1, y + 1, z + 1], [x, y + 1, z + 1],
                        [x, y, z + 1], [x + 1, y, z + 1], [x + 1, y + 1, z + 1]
                    ],
                    // Back face (-Z)
                    [
                        [x, y, z], [x, y + 1, z], [x + 1, y + 1, z],
                        [x, y, z], [x + 1, y + 1, z], [x + 1, y, z]
                    ]
                ];

                const faceNormals = [
                    [1, 0, 0], [-1, 0, 0],
                    [0, 1, 0], [0, -1, 0],
                    [0, 0, 1], [0, 0, -1]
                ];

                for (const pos of positions[face]) {
                    vertices.push(...pos);
                    colors.push(color.r, color.g, color.b);
                    normals.push(...faceNormals[face]);
                }
            }

            serialize() {
                return Array.from(this.blocks);
            }

            deserialize(data) {
                this.blocks = new Uint8Array(data);
                this.dirty = true;
            }
        }

        // World class
        class World {
            constructor(scene) {
                this.scene = scene;
                this.chunks = new Map();
                this.noise = new SimplexNoise(12345);
                this.renderDistance = 4;
            }

            getChunkKey(x, z) {
                return `${x},${z}`;
            }

            getChunk(x, z) {
                return this.chunks.get(this.getChunkKey(x, z));
            }

            loadChunk(x, z) {
                const key = this.getChunkKey(x, z);
                if (this.chunks.has(key)) return;
                
                const chunk = new Chunk(x, z, this);
                chunk.generate();
                chunk.buildMesh();
                this.chunks.set(key, chunk);
            }

            updateChunks(playerX, playerZ) {
                const chunkX = Math.floor(playerX / 16);
                const chunkZ = Math.floor(playerZ / 16);
                
                // Load chunks around player
                for (let x = -this.renderDistance; x <= this.renderDistance; x++) {
                    for (let z = -this.renderDistance; z <= this.renderDistance; z++) {
                        this.loadChunk(chunkX + x, chunkZ + z);
                    }
                }
                
                // Unload distant chunks
                for (const [key, chunk] of this.chunks) {
                    const dx = chunk.x - chunkX;
                    const dz = chunk.z - chunkZ;
                    if (Math.abs(dx) > this.renderDistance + 1 || Math.abs(dz) > this.renderDistance + 1) {
                        if (chunk.mesh) {
                            this.scene.remove(chunk.mesh);
                            chunk.mesh.geometry.dispose();
                            chunk.mesh.material.dispose();
                        }
                        this.chunks.delete(key);
                    }
                }
            }

            getBlock(x, y, z) {
                const chunkX = Math.floor(x / 16);
                const chunkZ = Math.floor(z / 16);
                const chunk = this.getChunk(chunkX, chunkZ);
                if (!chunk) return BlockType.AIR;
                
                const localX = ((x % 16) + 16) % 16;
                const localZ = ((z % 16) + 16) % 16;
                return chunk.getBlock(localX, y, localZ);
            }

            setBlock(x, y, z, type) {
                const chunkX = Math.floor(x / 16);
                const chunkZ = Math.floor(z / 16);
                const chunk = this.getChunk(chunkX, chunkZ);
                if (!chunk) return;
                
                const localX = ((x % 16) + 16) % 16;
                const localZ = ((z % 16) + 16) % 16;
                chunk.setBlock(localX, y, localZ, type);
                chunk.buildMesh();
            }

            save() {
                const data = {
                    chunks: {}
                };
                
                for (const [key, chunk] of this.chunks) {
                    data.chunks[key] = {
                        x: chunk.x,
                        z: chunk.z,
                        blocks: chunk.serialize()
                    };
                }
                
                localStorage.setItem('webcraft_world', JSON.stringify(data));
                console.log('World saved!');
            }

            load() {
                const savedData = localStorage.getItem('webcraft_world');
                if (!savedData) {
                    console.log('No saved world found');
                    return;
                }
                
                const data = JSON.parse(savedData);
                
                // Clear existing chunks
                for (const [key, chunk] of this.chunks) {
                    if (chunk.mesh) {
                        this.scene.remove(chunk.mesh);
                        chunk.mesh.geometry.dispose();
                        chunk.mesh.material.dispose();
                    }
                }
                this.chunks.clear();
                
                // Load saved chunks
                for (const key in data.chunks) {
                    const chunkData = data.chunks[key];
                    const chunk = new Chunk(chunkData.x, chunkData.z, this);
                    chunk.deserialize(chunkData.blocks);
                    chunk.buildMesh();
                    this.chunks.set(key, chunk);
                }
                
                console.log('World loaded!');
            }
        }

        // Player class
        class Player {
            constructor(camera, world) {
                this.camera = camera;
                this.world = world;
                this.position = new THREE.Vector3(8, 30, 8);
                this.velocity = new THREE.Vector3(0, 0, 0);
                this.onGround = false;
                this.speed = 5;
                this.jumpSpeed = 8;
                this.gravity = -20;
                this.width = 0.6;
                this.height = 1.8;
                this.eyeHeight = 1.6;
                
                this.moveForward = false;
                this.moveBackward = false;
                this.moveLeft = false;
                this.moveRight = false;
                this.isJumping = false;
                this.isSprinting = false;
                
                this.pitch = 0;
                this.yaw = 0;
                
                this.selectedBlockType = BlockType.STONE;
            }

            update(deltaTime) {
                // Apply gravity
                this.velocity.y += this.gravity * deltaTime;
                
                // Calculate movement
                const moveSpeed = (this.isSprinting ? this.speed * 1.5 : this.speed) * deltaTime;
                const forward = new THREE.Vector3();
                const right = new THREE.Vector3();
                
                this.camera.getWorldDirection(forward);
                forward.y = 0;
                forward.normalize();
                
                right.crossVectors(forward, new THREE.Vector3(0, 1, 0));
                
                if (this.moveForward) {
                    this.velocity.x += forward.x * moveSpeed;
                    this.velocity.z += forward.z * moveSpeed;
                }
                if (this.moveBackward) {
                    this.velocity.x -= forward.x * moveSpeed;
                    this.velocity.z -= forward.z * moveSpeed;
                }
                if (this.moveLeft) {
                    this.velocity.x -= right.x * moveSpeed;
                    this.velocity.z -= right.z * moveSpeed;
                }
                if (this.moveRight) {
                    this.velocity.x += right.x * moveSpeed;
                    this.velocity.z += right.z * moveSpeed;
                }
                
                // Apply friction
                this.velocity.x *= 0.9;
                this.velocity.z *= 0.9;
                
                // Jump
                if (this.isJumping && this.onGround) {
                    this.velocity.y = this.jumpSpeed;
                }
                
                // Apply velocity with collision
                this.moveWithCollision(deltaTime);
                
                // Update camera
                this.camera.position.copy(this.position);
                this.camera.position.y += this.eyeHeight;
                this.camera.rotation.order = 'YXZ';
                this.camera.rotation.y = this.yaw;
                this.camera.rotation.x = this.pitch;
            }

            moveWithCollision(deltaTime) {
                const newPos = this.position.clone();
                newPos.add(this.velocity.clone().multiplyScalar(deltaTime));
                
                // Check collision for each axis separately
                const testPos = this.position.clone();
                
                // X axis
                testPos.x = newPos.x;
                if (!this.checkCollision(testPos)) {
                    this.position.x = newPos.x;
                } else {
                    this.velocity.x = 0;
                }
                
                // Y axis
                testPos.x = this.position.x;
                testPos.y = newPos.y;
                if (!this.checkCollision(testPos)) {
                    this.position.y = newPos.y;
                    this.onGround = false;
                } else {
                    if (this.velocity.y < 0) {
                        this.onGround = true;
                    }
                    this.velocity.y = 0;
                }
                
                // Z axis
                testPos.y = this.position.y;
                testPos.z = newPos.z;
                if (!this.checkCollision(testPos)) {
                    this.position.z = newPos.z;
                } else {
                    this.velocity.z = 0;
                }
            }

            checkCollision(pos) {
                const minX = Math.floor(pos.x - this.width / 2);
                const maxX = Math.floor(pos.x + this.width / 2);
                const minY = Math.floor(pos.y);
                const maxY = Math.floor(pos.y + this.height);
                const minZ = Math.floor(pos.z - this.width / 2);
                const maxZ = Math.floor(pos.z + this.width / 2);
                
                for (let x = minX; x <= maxX; x++) {
                    for (let y = minY; y <= maxY; y++) {
                        for (let z = minZ; z <= maxZ; z++) {
                            const block = this.world.getBlock(x, y, z);
                            if (block !== BlockType.AIR && BlockData[block].solid) {
                                return true;
                            }
                        }
                    }
                }
                return false;
            }

            breakBlock() {
                const hit = this.raycast();
                if (hit) {
                    this.world.setBlock(hit.x, hit.y, hit.z, BlockType.AIR);
                }
            }

            placeBlock() {
                const hit = this.raycast();
                if (hit && hit.face) {
                    const placePos = {
                        x: hit.x + hit.face.x,
                        y: hit.y + hit.face.y,
                        z: hit.z + hit.face.z
                    };
                    
                    // Don't place block if it would collide with player
                    const playerBox = {
                        minX: this.position.x - this.width / 2,
                        maxX: this.position.x + this.width / 2,
                        minY: this.position.y,
                        maxY: this.position.y + this.height,
                        minZ: this.position.z - this.width / 2,
                        maxZ: this.position.z + this.width / 2
                    };
                    
                    if (placePos.x >= playerBox.minX - 1 && placePos.x <= playerBox.maxX &&
                        placePos.y >= playerBox.minY - 1 && placePos.y <= playerBox.maxY &&
                        placePos.z >= playerBox.minZ - 1 && placePos.z <= playerBox.maxZ) {
                        return;
                    }
                    
                    this.world.setBlock(placePos.x, placePos.y, placePos.z, this.selectedBlockType);
                }
            }

            raycast() {
                const start = this.camera.position.clone();
                const direction = new THREE.Vector3();
                this.camera.getWorldDirection(direction);
                
                const maxDistance = 5;
                const step = 0.1;
                let lastBlock = null;
                let lastFace = null;
                
                for (let d = 0; d < maxDistance; d += step) {
                    const pos = start.clone().add(direction.clone().multiplyScalar(d));
                    const x = Math.floor(pos.x);
                    const y = Math.floor(pos.y);
                    const z = Math.floor(pos.z);
                    
                    const block = this.world.getBlock(x, y, z);
                    if (block !== BlockType.AIR && BlockData[block].solid) {
                        return {
                            x, y, z,
                            face: lastFace
                        };
                    }
                    
                    if (!lastBlock || lastBlock.x !== x || lastBlock.y !== y || lastBlock.z !== z) {
                        if (lastBlock) {
                            lastFace = {
                                x: x - lastBlock.x,
                                y: y - lastBlock.y,
                                z: z - lastBlock.z
                            };
                        }
                        lastBlock = { x, y, z };
                    }
                }
                
                return null;
            }
        }

        // Main game class
        class Game {
            constructor() {
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                this.world = null;
                this.player = null;
                this.clock = new THREE.Clock();
                this.isLocked = false;
                
                this.init();
            }

            init() {
                // Setup Three.js
                this.scene = new THREE.Scene();
                this.scene.fog = new THREE.Fog(0x87CEEB, 10, 200);
                
                this.camera = new THREE.PerspectiveCamera(
                    75,
                    window.innerWidth / window.innerHeight,
                    0.1,
                    1000
                );
                
                this.renderer = new THREE.WebGLRenderer({
                    canvas: document.getElementById('gameCanvas'),
                    antialias: true
                });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setClearColor(0x87CEEB);
                this.renderer.shadowMap.enabled = false;
                
                // Lighting
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
                this.scene.add(ambientLight);
                
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.4);
                directionalLight.position.set(1, 1, 0.5);
                this.scene.add(directionalLight);
                
                // Initialize world and player
                this.world = new World(this.scene);
                this.player = new Player(this.camera, this.world);
                
                // Setup controls
                this.setupControls();
                
                // Setup UI
                this.setupUI();
                
                // Start button
                document.getElementById('startBtn').addEventListener('click', () => {
                    document.getElementById('startScreen').style.opacity = '0';
                    setTimeout(() => {
                        document.getElementById('startScreen').style.display = 'none';
                    }, 500);
                    this.startGame();
                });
                
                // Handle window resize
                window.addEventListener('resize', () => {
                    this.camera.aspect = window.innerWidth / window.innerHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                });
            }

            setupControls() {
                // Pointer lock
                const canvas = this.renderer.domElement;
                canvas.addEventListener('click', () => {
                    if (!this.isLocked) {
                        canvas.requestPointerLock();
                    }
                });
                
                document.addEventListener('pointerlockchange', () => {
                    this.isLocked = document.pointerLockElement === canvas;
                });
                
                // Mouse movement
                document.addEventListener('mousemove', (e) => {
                    if (!this.isLocked) return;
                    
                    const sensitivity = 0.002;
                    this.player.yaw -= e.movementX * sensitivity;
                    this.player.pitch -= e.movementY * sensitivity;
                    this.player.pitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, this.player.pitch));
                });
                
                // Mouse clicks
                canvas.addEventListener('mousedown', (e) => {
                    if (!this.isLocked) return;
                    
                    e.preventDefault();
                    if (e.button === 0) {
                        this.player.breakBlock();
                    } else if (e.button === 2) {
                        this.player.placeBlock();
                    }
                });
                
                canvas.addEventListener('contextmenu', (e) => e.preventDefault());
                
                // Keyboard
                document.addEventListener('keydown', (e) => {
                    switch(e.code) {
                        case 'KeyW': this.player.moveForward = true; break;
                        case 'KeyS': this.player.moveBackward = true; break;
                        case 'KeyA': this.player.moveLeft = true; break;
                        case 'KeyD': this.player.moveRight = true; break;
                        case 'Space': this.player.isJumping = true; break;
                        case 'ShiftLeft': this.player.isSprinting = true; break;
                        case 'KeyE': this.world.save(); break;
                        case 'KeyR': this.world.load(); break;
                        case 'Digit1':
                        case 'Digit2':
                        case 'Digit3':
                        case 'Digit4':
                        case 'Digit5':
                        case 'Digit6':
                        case 'Digit7':
                        case 'Digit8':
                        case 'Digit9':
                            const slot = parseInt(e.code.substr(5)) - 1;
                            this.selectHotbarSlot(slot);
                            break;
                    }
                });
                
                document.addEventListener('keyup', (e) => {
                    switch(e.code) {
                        case 'KeyW': this.player.moveForward = false; break;
                        case 'KeyS': this.player.moveBackward = false; break;
                        case 'KeyA': this.player.moveLeft = false; break;
                        case 'KeyD': this.player.moveRight = false; break;
                        case 'Space': this.player.isJumping = false; break;
                        case 'ShiftLeft': this.player.isSprinting = false; break;
                    }
                });
            }

            setupUI() {
                // Create hotbar
                const hotbar = document.getElementById('hotbar');
                const blockTypes = [
                    BlockType.STONE,
                    BlockType.DIRT,
                    BlockType.GRASS,
                    BlockType.WOOD,
                    BlockType.PLANKS,
                    BlockType.COBBLESTONE,
                    BlockType.SAND,
                    BlockType.LEAVES,
                    BlockType.WATER
                ];
                
                blockTypes.forEach((type, index) => {
                    const slot = document.createElement('div');
                    slot.className = 'hotbar-slot';
                    if (index === 0) slot.classList.add('active');
                    
                    const preview = document.createElement('canvas');
                    preview.className = 'block-preview';
                    preview.width = 30;
                    preview.height = 30;
                    
                    const ctx = preview.getContext('2d');
                    const color = BlockData[type].color;
                    if (color) {
                        ctx.fillStyle = `#${color.toString(16).padStart(6, '0')}`;
                        ctx.fillRect(0, 0, 30, 30);
                    }
                    
                    const number = document.createElement('div');
                    number.className = 'hotbar-number';
                    number.textContent = index + 1;
                    
                    slot.appendChild(preview);
                    slot.appendChild(number);
                    slot.title = BlockData[type].name;
                    
                    slot.addEventListener('click', () => {
                        this.selectHotbarSlot(index);
                    });
                    
                    hotbar.appendChild(slot);
                });
            }

            selectHotbarSlot(index) {
                const slots = document.querySelectorAll('.hotbar-slot');
                const blockTypes = [
                    BlockType.STONE,
                    BlockType.DIRT,
                    BlockType.GRASS,
                    BlockType.WOOD,
                    BlockType.PLANKS,
                    BlockType.COBBLESTONE,
                    BlockType.SAND,
                    BlockType.LEAVES,
                    BlockType.WATER
                ];
                
                if (index >= 0 && index < blockTypes.length) {
                    slots.forEach(s => s.classList.remove('active'));
                    slots[index].classList.add('active');
                    this.player.selectedBlockType = blockTypes[index];
                }
            }

            startGame() {
                // Generate initial chunks
                this.world.updateChunks(this.player.position.x, this.player.position.z);
                
                // Start game loop
                this.animate();
            }

            animate() {
                requestAnimationFrame(() => this.animate());
                
                const deltaTime = Math.min(this.clock.getDelta(), 0.1);
                
                // Update
                this.player.update(deltaTime);
                this.world.updateChunks(this.player.position.x, this.player.position.z);
                
                // Update UI
                document.getElementById('position').textContent = 
                    `${Math.floor(this.player.position.x)}, ${Math.floor(this.player.position.y)}, ${Math.floor(this.player.position.z)}`;
                document.getElementById('chunks').textContent = this.world.chunks.size;
                document.getElementById('fps').textContent = Math.round(1 / deltaTime);
                
                // Render
                this.renderer.render(this.scene, this.camera);
            }
        }

        // Start the game
        const game = new Game();
    </script>
</body>
</html>